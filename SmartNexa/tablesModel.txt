When building a Django model for an industrial e-commerce project, you need to define fields that represent products, categories, inventory, pricing, customer details, and transactions. Industrial e-commerce typically involves B2B (business-to-business) sales, so youâ€™ll also need to consider elements like bulk pricing, shipping, procurement, and potentially complex product configurations (e.g., custom sizes, part numbers, etc.).

Here are some essential Django model fields for various aspects of an industrial e-commerce platform:

1. Product Model (Represents individual items)

from django.db import models

class Product(models.Model):
    sku = models.CharField(max_length=100, unique=True)  # Stock Keeping Unit
    name = models.CharField(max_length=255)
    description = models.TextField()
    category = models.ForeignKey('Category', on_delete=models.SET_NULL, null=True)
    price = models.DecimalField(max_digits=10, decimal_places=2)  # Base price
    weight = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)  # For shipping calculations
    dimensions = models.CharField(max_length=255, null=True, blank=True)  # Length, width, height
    stock_quantity = models.IntegerField(default=0)  # Inventory
    is_active = models.BooleanField(default=True)  # Product availability
    date_added = models.DateTimeField(auto_now_add=True)
    manufacturer = models.CharField(max_length=255, blank=True, null=True)  # For industrial parts
    reorder_level = models.IntegerField(default=10)  # Minimum stock level for reorder alerts
    custom_attributes = models.JSONField(default=dict, blank=True)  # Custom fields for variations (e.g., voltage, color)

    def __str__(self):
        return self.name
2. Category Model (Categorizes products)

class Category(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    parent_category = models.ForeignKey('self', null=True, blank=True, on_delete=models.SET_NULL)
    slug = models.SlugField(unique=True)
    image = models.ImageField(upload_to='category_images/', null=True, blank=True)

    def __str__(self):
        return self.name
3. Pricing Model (For storing different pricing tiers or volume discounts)

class Pricing(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    min_quantity = models.IntegerField(default=1)
    max_quantity = models.IntegerField(default=100)
    price = models.DecimalField(max_digits=10, decimal_places=2)  # Price for this quantity range

    def __str__(self):
        return f"{self.product.name} - {self.min_quantity} to {self.max_quantity} units"
4. Order Model (Represents a purchase order)

class Order(models.Model):
    customer = models.ForeignKey('Customer', on_delete=models.CASCADE)
    total_amount = models.DecimalField(max_digits=12, decimal_places=2)
    status = models.CharField(max_length=50, choices=[('pending', 'Pending'), ('completed', 'Completed'), ('shipped', 'Shipped')])
    shipping_address = models.TextField()
    billing_address = models.TextField()
    date_ordered = models.DateTimeField(auto_now_add=True)
    date_shipped = models.DateTimeField(null=True, blank=True)

    def __str__(self):
        return f"Order {self.id} - {self.customer.name}"
5. OrderItem Model (Line items in an order)

class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.IntegerField()
    price_per_unit = models.DecimalField(max_digits=10, decimal_places=2)

    def total_price(self):
        return self.quantity * self.price_per_unit

    def __str__(self):
        return f"{self.product.name} (x{self.quantity})"
6. Customer Model (Represents customers)

class Customer(models.Model):
    company_name = models.CharField(max_length=255)
    contact_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone_number = models.CharField(max_length=20, null=True, blank=True)
    address = models.TextField()
    shipping_address = models.TextField(null=True, blank=True)
    billing_address = models.TextField(null=True, blank=True)
    account_balance = models.DecimalField(max_digits=12, decimal_places=2, default=0.00)  # For credit systems
    is_active = models.BooleanField(default=True)
    date_joined = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.company_name
7. Inventory Model (Tracks stock and inventory updates)

class Inventory(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity_in_stock = models.IntegerField()
    quantity_sold = models.IntegerField(default=0)
    quantity_returned = models.IntegerField(default=0)
    last_updated = models.DateTimeField(auto_now=True)

    def update_inventory(self, quantity_sold):
        self.quantity_in_stock -= quantity_sold
        self.quantity_sold += quantity_sold
        self.save()

    def __str__(self):
        return f"Inventory for {self.product.name}"
8. Payment Model (Tracks payments for orders)

class Payment(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE)
    amount_paid = models.DecimalField(max_digits=12, decimal_places=2)
    payment_method = models.CharField(max_length=50, choices=[('credit_card', 'Credit Card'), ('bank_transfer', 'Bank Transfer'), ('paypal', 'PayPal')])
    payment_status = models.CharField(max_length=50, choices=[('pending', 'Pending'), ('completed', 'Completed'), ('failed', 'Failed')])
    payment_date = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Payment for Order {self.order.id} - {self.payment_status}"
9. Shipping Model (Tracks shipping details)

class Shipping(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE)
    shipping_method = models.CharField(max_length=100)
    tracking_number = models.CharField(max_length=100, null=True, blank=True)
    shipping_cost = models.DecimalField(max_digits=10, decimal_places=2)
    shipping_date = models.DateTimeField(null=True, blank=True)
    delivery_date = models.DateTimeField(null=True, blank=True)
    status = models.CharField(max_length=50, choices=[('pending', 'Pending'), ('shipped', 'Shipped'), ('delivered', 'Delivered')])

    def __str__(self):
        return f"Shipping for Order {self.order.id} - {self.status}"
10. Supplier Model (For managing suppliers of industrial goods)

class Supplier(models.Model):
    name = models.CharField(max_length=255)
    contact_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone_number = models.CharField(max_length=20)
    address = models.TextField()

    def __str__(self):
        return self.name
11. Product Review Model (Customer feedback on products)

class ProductReview(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    rating = models.PositiveIntegerField(choices=[(1, '1 Star'), (2, '2 Stars'), (3, '3 Stars'), (4, '4 Stars'), (5, '5 Stars')])
    review_text = models.TextField(null=True, blank=True)
    date_reviewed = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Review for {self.product.name} by {self.customer.company_name}"

Additional Considerations
Multi-currency and Tax: If your e-commerce site operates in multiple countries or regions, consider adding fields for handling different currencies, VAT/GST taxes, etc.
Product Variants: If your products have variants (e.g., size, color, voltage), create a ProductVariant model with foreign keys to Product and additional attributes for variants.
Discounts/Promotions: You might need models to manage discount codes, promotional pricing, or bulk pricing.
These models provide the basic structure for building an industrial e-commerce platform with Django. You can extend them to accommodate more specific requirements, such as contract pricing, procurement processes, purchase orders, or more advanced inventory management systems.